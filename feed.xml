<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Digital Insights</title><id>https://miles-harvey.tiiny.site/feed.xml</id><subtitle>Recent Posts</subtitle><updated>2022-01-05T14:35:51Z</updated><link href="miles-harvey.tiiny.site/feed.xml" rel="self" /><link href="miles-harvey.tiiny.site" /><entry><title>Object-Oriented Programming: Advantages and Disadvantages</title><id>https://miles-harvey.tiiny.site/object-oriented-programming-advantages-and-disadvantages/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-03-27T15:16:00Z</updated><link href="https://miles-harvey.tiiny.site/object-oriented-programming-advantages-and-disadvantages/index.html" rel="alternate" /><summary type="html">&lt;p&gt;Object-Oriented Programming is a programming paradigm popular with many developers in which data, and the functions that act on the data - known as &amp;quot;methods&amp;quot; - are bundled together as a single unit, called an object. The blueprint that determines the methods and the kinds of data that the object will be attributed with is called a Class.&lt;/p&gt;&lt;h1&gt;Advantages&lt;/h1&gt;&lt;h2&gt;Modularity&lt;/h2&gt;&lt;p&gt;In OOP, the code is divided largely into separate objects, which are components that can be created and used in many different ways in many different parts of the application. In this way the code ends up being very modular. This means it can be easily rearranged and reused.&lt;/p&gt;&lt;h3&gt;Flexible and adaptable&lt;/h3&gt;&lt;p&gt;Being able to rearrange and reuse components leads to a flexible codebase that can adapt according to the requirements of the project. Increased reusability of code means less time spent writing new code, which means it can be rapidly iterated upon.&lt;/p&gt;&lt;h3&gt;Abstracted complexity, clearer structure&lt;/h3&gt;&lt;p&gt;For larger, more complex projects, the modularity helps reduce the complexity in understanding the overall flow of the software by abstracting away parts of it into self-contained components (classes and objects). Other programming paradigms that don't abstract data and functions away into self-contained components, such as procedural programming, will quickly increase in complexity as the project grows, and would be more difficult to modify.&lt;/p&gt;&lt;p&gt;The reduced complexity and clearer structure makes it easier for developers to understand the codebase and thus develop the software.&lt;/p&gt;&lt;h3&gt;Intuitive&lt;/h3&gt;&lt;p&gt;The modularity of Object-Oriented Programming is more inuitive to people because it models the way people naturally abstract/perceive reality. There are far too many processes going on in the world for people to be aware of all the time, so we abstract them into objects according to how we use them: for instance, when people think of a car, typically they will think of it in terms of how they use it, as something they get in, start, and move using pedals, steering wheel, etc, in order to control it. All these aspects are abstractions of what is really happening, for example pushing the accelerator doesn't inherently make the car go forward, pushing the accelerator increases fuel flow into the engine, which causes more power to be output by the engine, which forces the back wheels to turn.&lt;/p&gt;&lt;h3&gt;Extensible&lt;/h3&gt;&lt;p&gt;Objects and classes can be easily extended with new attributes and behaviours.&lt;/p&gt;&lt;h3&gt;Improved maintainability&lt;/h3&gt;&lt;p&gt;Due to all these reasons, the code is ultimately more maintainable than with other paradigms that don't provide these advantages.&lt;/p&gt;&lt;h1&gt;Disadvantages&lt;/h1&gt;&lt;h2&gt;Steeper learning curve&lt;/h2&gt;&lt;p&gt;The structure of a piece of software written in the Object-Oriented paradigm is not as straightforward as other paradigms like procedural programming, where a series of computational steps are executed in a linear way. Object-oriented programming requires an understanding of how objects interact with eachother, and how they are formed with classes, which also include concepts such as inheritance and polymorphism.&lt;/p&gt;&lt;p&gt;For this reason, OOP is more suited for larger, more complex software where the initial time cost of understanding OOP is lower than the developmental cost of not abstracting the software into components, which would become a bigger problem as the product development progresses.&lt;/p&gt;&lt;h2&gt;Less linear structure could lead to more bugs&lt;/h2&gt;&lt;p&gt;The overall flow of the program will be more complex than with a more linear paradigm like Procedural programming. This could lead to more bugs.&lt;/p&gt;&lt;h2&gt;Less efficient than other paradigms&lt;/h2&gt;&lt;p&gt;In terms of processing instructions, there is more overhead with OOP, which means it isn't as computionally efficient as other programming paradigms that don't facilitate abstractions as much, such as procedural programming. This may make OOP less ideal for computers with scarce processing power/resources, such as for small, low power computers designed for reading sensor data in a remote location and transmitting it back to a central location.&lt;/p&gt;&lt;p&gt;The additional abstraction also typically means more lines of code are used to define these abstractions, which will result in a larger software than would be for a less abstracted paradigm like procedural programming.&lt;/p&gt;&lt;p&gt;Source(s):
https://resources.saylor.org/wwwresources/archived/site/wp-content/uploads/2013/02/CS101-2.1.2-AdvantagesDisadvantagesOfOOP-FINAL.pdf&lt;/p&gt;</summary></entry><entry><title>V Model Strengths and Weaknesses</title><id>https://miles-harvey.tiiny.site/v-model/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-03-26T19:49:00Z</updated><link href="https://miles-harvey.tiiny.site/v-model/index.html" rel="alternate" /><summary type="html">&lt;p&gt;The &amp;quot;V&amp;quot; software development model is similar to the waterfall model in that each stage corresponds to a phase in the software development lifecycle, however instead of testing being a single stage after the development of the software, has testing applied to it.&lt;/p&gt;&lt;h1&gt;Strengths&lt;/h1&gt;&lt;h2&gt;More reliably structured codebase&lt;/h2&gt;&lt;p&gt;Emphasis on heavy testing encourages designing a system of which it's components can be tested, which implicitly encourages programmers to compartmentalise components, keeping them separate from eachother and thus the codebase being more structured.&lt;/p&gt;&lt;p&gt;Since testing at every stage gives feedback to developers as to how well components are differentiated and structured throughout the development lifecycle, rather than towards the end like with other methodologies, the structure of the software will be improved upon as the project progresses.&lt;/p&gt;&lt;p&gt;Since the plan doesn't change until it's released, more focus can be made on planning the requirements and a solid codebase/structure as it won't be changed. This will result in a more solidly structured codebase that is better thought-out and so more reliable.&lt;/p&gt;&lt;h2&gt;Verification and validation.&lt;/h2&gt;&lt;h2&gt;Tests are made during the creation of the project/product structure.&lt;/h2&gt;&lt;h2&gt;Software&lt;/h2&gt;&lt;p&gt;&amp;lt;features of software that V model is bad for&amp;gt;
&amp;lt;Examples of software&amp;gt;
Operating systems.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ATMs.

Flight software - avionics.

Power plant operator software.

Mechanical devices/equipment that are controlled with a computer.

Ultimately, any kind of software which needs to be bug-free before release, that if isn't would cause harm to [quality of] life.
    Also, any kind of software to create a product ready to be used straight away.&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;Weaknesses:&lt;/h1&gt;&lt;h2&gt;Time&lt;/h2&gt;&lt;p&gt;More time spent on testing, less time spent on other things.&lt;/p&gt;&lt;h2&gt;Client/user feedback&lt;/h2&gt;&lt;p&gt;No feedback until release - Interface could be suboptimal.&lt;/p&gt;&lt;h2&gt;Lack of iteration and adaptability&lt;/h2&gt;&lt;p&gt;No iteration on product - project lives and dies by the planning stage.
Not able to adapt to changes, e.g. new technologies.&lt;/p&gt;&lt;h2&gt;Rigidly reliant on specification.&lt;/h2&gt;&lt;h2&gt;Software&lt;/h2&gt;&lt;p&gt;&amp;lt;features of software that V model is bad for&amp;gt;
&amp;lt;Examples of software&amp;gt;&lt;/p&gt;&lt;h1&gt;Conclusion&lt;/h1&gt;</summary></entry><entry><title>Feature-Driven Software Development</title><id>https://miles-harvey.tiiny.site/feature-driven/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-03-22T19:31:00Z</updated><link href="https://miles-harvey.tiiny.site/feature-driven/index.html" rel="alternate" /><summary type="html">&lt;p&gt;Feature-Driven development is a software development methodology that focuses it's goals and process around developing features of a given product, unlike other methodologies that center around the process of development itself (such as scrum that divides the team into sub-teams who work in sprints), or center around other goals (such as lean-development which aims to produce a minimum viable product, or scrum which centers goals on components of software).&lt;/p&gt;&lt;p&gt;The feature-driven development methodology takes the software development lifecycle and centers goals around features, so after building a model of the software to build, a features list is built, and then a plan and design is built by feature, and finally the software itself is built by feature.&lt;/p&gt;&lt;p&gt;The main benefit is the simplicity of the five-steps of the methodology, which aids in allowing for larger teams to progress faster in developing the software, as there is less rigid management of the development process. The lack of specification of the development process itself means it is open to whatever the company culture works best with.&lt;/p&gt;&lt;p&gt;The main disadvantage is that the lack of specification of the development process by the methodology means that it is highly dependent on lead developers or programmers to guide the process. It also doesn't work as efficiently as other methodologies for smaller projects, because the benefits of the speed of product development has less effect on a smaller project, while the negatives of a less rigid development process are more pronounced compared with other methodologies. Documentation is also not prioritised, so there may be less, which could result in the software not being very maintainable (due to lack of developer documentation), and the lack of user documentation makes it unviable for software that offers complex features that would require documentation to teach the user how to use the features.&lt;/p&gt;&lt;p&gt;Real world software that may be built using this methodology may be products that aim to be brought to market as soon as possible before competitors, and software that isn't mission-critical (due to it's focus on quickly producing new features, rather than planning a structure of how those features should best be implemented, such that the software will have fewer bugs and be more reliable). These types of software could be for entertainment applications that aren't guided by the requirements of a highly structured workflow, such as chat, video and small games (the complexity of larger games would require a more structured development process that would produce a codebase that could be more reliably built upon, and that the structure of which would be immediately understood by other developers and development teams working on the project), also small niche applications for a specific market, where the code wouldn't be too complex, and would be designed for adding features that provide functionality for that market.&lt;/p&gt;&lt;p&gt;Source(s):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;https://www.productplan.com/glossary/feature-driven-development/&lt;/li&gt;&lt;/ul&gt;</summary></entry><entry><title>Incremental Software Development Model</title><id>https://miles-harvey.tiiny.site/incremental-model-benefits/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-03-22T19:15:00Z</updated><link href="https://miles-harvey.tiiny.site/incremental-model-benefits/index.html" rel="alternate" /><summary type="html">&lt;p&gt;The Incremental Model may be beneficial when customers' requirements could change before the project is completed, because the product is developed by developing components of the project and showing them to the client once they are complete, rather than only showing the whole project once it's completed, and the project is defined as completed when all customer requirements are met rather than when the initial plan has been met.&lt;/p&gt;&lt;p&gt;Since each increment completes one element of the product and is reviewed by the client, the project can adapt to better suit the client's requirements through regular feedback by adding functionality that the client did not realise they needed before having reviewed a function that was added in an increment. It also wastes less development resources on further developing components that the client realises they don't need.&lt;/p&gt;&lt;p&gt;The kind of software this development methodology would benefit is software that is designed for aiding a work environment which may have changing workflows, such as a business interacting with different types of products in different ways. In this example, the incremental model would allow the software to be focused on adding functionality that fits new requirements of the client in aiding the workflow of their business, and allows for feedback from the client (as to what works better at aiding the internal processes/procedures of their business) to guide the development of the software in terms of functionality.&lt;/p&gt;</summary></entry><entry><title>The Character Data Type</title><id>https://miles-harvey.tiiny.site/data-type/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-03-22T18:57:00Z</updated><link href="https://miles-harvey.tiiny.site/data-type/index.html" rel="alternate" /><summary type="html">&lt;p&gt;As a written symbol, a character is a unit of information that corresponds to a grapheme or symbol in written language, such as a letter, punctuation or a digit. A character in computing is a binary number that represents one of these written symbols. The representation of a given binary number is determined by which symbol from a predefined set of written symbols is represented by that binary number. These sets of symbols, each associated with a binary number, are known as character sets. The standard character sets are ASCII (American Standard Code for Information Interchange) and Unicode.&lt;/p&gt;&lt;p&gt;There are also characters, which do not represent a written symbol, called &amp;quot;control codes&amp;quot;. Control codes are instructions to format or process text, for example a carriage return. Spaces and tabs, known as &amp;quot;whitespace&amp;quot;, are also represented as characters.&lt;/p&gt;&lt;p&gt;Historically, the term character has also been used to denote a specific number of adjacent binary digits.&lt;/p&gt;&lt;p&gt;Characters are typically combined to form a sequence, which are referred to as &amp;quot;strings&amp;quot;.&lt;/p&gt;&lt;p&gt;Source(s):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;https://www.bbc.co.uk/bitesize/guides/zfspfcw/revision/7&lt;/li&gt;&lt;li&gt;https://en.wikipedia.org/wiki/Character_(computing)&lt;/li&gt;&lt;/ul&gt;</summary></entry><entry><title>Object-Oriented Programming</title><id>https://miles-harvey.tiiny.site/object-oriented-programming/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-02-25T12:54:00Z</updated><link href="https://miles-harvey.tiiny.site/object-oriented-programming/index.html" rel="alternate" /><summary type="html">&lt;p&gt;Object Oriented Programming is a paradigm in which everything is treated as objects with attributes - for example, variables that describe the particular features of the 'object' - and defined ways of interacting with themselves and eachother - methods, which are functions associated with an object that function as an interface to read or change the state of the object (such as accessing and modify data fields of itself). The software is structured as objects interacting with eachother.&lt;/p&gt;&lt;p&gt;The way these features and interactions are defined is usually organised with classes, which define a 'class' of object, which determines what available attributes (variables) and actions (methods) that an object created from it (instantiated) has.&lt;/p&gt;&lt;p&gt;New classes can be created from existing classes, in which these defined attributes and actions are inherited from the existing class, and attributes/actions can be added/changed/removed to model the new class of object more specifically/accurately, while reusing concepts defined in the inherited class. Reusing attributes/actions in this way not only reduces repeated code, but keeps the code more organised, and depending on the type of software, objects will remain 'compatible' with eachother, i.e. they can interact with eachother using methods.&lt;/p&gt;&lt;p&gt;Examples of conceptual classes:&lt;/p&gt;&lt;p&gt;Class: Utensil
Object (Instance of 'Utensil' class): Spoon
Attributes/characteristics: Material, weight, shape, colour&lt;/p&gt;&lt;p&gt;Class: Hand
Object (Instance of 'Hand' class): Left/right hand
Interface: Shoulder&lt;/p&gt;&lt;p&gt;Todo: investigate classes themselves being objects
Strengths and weaknesses
Expand on examples&lt;/p&gt;</summary></entry><entry><title>Data types: Real</title><id>https://miles-harvey.tiiny.site/real-data-type/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-02-10T12:00:00Z</updated><link href="https://miles-harvey.tiiny.site/real-data-type/index.html" rel="alternate" /><summary type="html">&lt;p&gt;In Mathematics, a Real is a number that can be represented as an infinite decimal expansion, e.g. 2/3.&lt;/p&gt;&lt;p&gt;The Real data type represents these types of numbers. Computers cannot represent them exactly because these numbers are not countable, so they use an approximation using one of four types of numbers:&lt;/p&gt;&lt;p&gt;Rational numbers – Stores numberator and denominator as integers.&lt;/p&gt;&lt;p&gt;Fixed-point numbers – ?&lt;/p&gt;&lt;p&gt;Floating-point numbers – ?&lt;/p&gt;&lt;p&gt;Decimal numbers – ?&lt;/p&gt;</summary></entry><entry><title>Logic gates</title><id>https://miles-harvey.tiiny.site/logic-gates/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-02-10T10:00:00Z</updated><link href="https://miles-harvey.tiiny.site/logic-gates/index.html" rel="alternate" /><summary type="html">&lt;p&gt;Logic gates are a form of logic in which &amp;quot;gates&amp;quot; return true/false values depending on the combination of two true/false values provided as &amp;quot;inputs&amp;quot; to the logic gate. Transisters physically let electricity flow according to the rules of these conceptual logic &amp;quot;gates&amp;quot;, using binary logic to represent True/1 or False/0, with a flow of electricity representing 1, and no electrical flow representing 0.&lt;/p&gt;&lt;p&gt;The main three logic gates:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;OR || - True if one or both are true&lt;/li&gt;&lt;li&gt;NOT ! - True if input is false&lt;/li&gt;&lt;li&gt;AND &amp;amp;&amp;amp; - True if both inputs are true&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Truth table for AND:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;A|B|Output
-|-|------
0|0|0
0|1|0
1|0|0
1|1|1&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;NOR - not or: false if either or both of the inputs are true&lt;/li&gt;&lt;li&gt;NAND - Not and: False if both inputs are true, otherwise true&lt;/li&gt;&lt;li&gt;XOR - Exclusive or:  true if one of them is true, False if both inputs are true or false&lt;/li&gt;&lt;li&gt;XNOR - Exclusive not or: true if either none or both of the inputs are true, false if one of the inputs is true&lt;/li&gt;&lt;li&gt;BUFFER - Buff up the input&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Relational and logical operators: || &amp;amp;&amp;amp; ! &amp;lt;= &amp;gt;= ==.&lt;/p&gt;&lt;p&gt;https://academo.org/demos/logic-gate-simulator/&lt;/p&gt;</summary></entry><entry><title>Iterative Development Model</title><id>https://miles-harvey.tiiny.site/iterative-development-model/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-02-09T12:00:00Z</updated><link href="https://miles-harvey.tiiny.site/iterative-development-model/index.html" rel="alternate" /><summary type="html">&lt;p&gt;The iterative model is a software development model focused on regularly iterating on the software, built on a deliberately small specification.&lt;/p&gt;&lt;p&gt;Weaknesses – A minimal specification combined with encouraging an open-ended goal without a clear endpoint can encourage feature creep which will eat up time.
– A lack of specification can result in inefficient use of time due to a) not planning beforehand how much time to spend on which features, and b) not structuring the software itself in a way that results in a project which fits the specification, rather than an ongoing specification that the project has to adapt to, which takes time to do.
Needing to change code to fit new aspects of specification.
– Spending equal amounts of time on different features&lt;/p&gt;&lt;p&gt;Strengths – Capturing minimum specifications leaves specification open to adapting as new external and internal changes affect the project, such as new technologies, new features, new market conditions.
Openness to change to the specifications allows for trying new things which help the project itself adapt to those external/internal changes, such as trying a new feature for a changed market condition, and rejecting it if necessary.&lt;/p&gt;</summary></entry><entry><title>Syllogisms</title><id>https://miles-harvey.tiiny.site/syllogisms/index.html</id><author><name>Miles Harvey</name><email>none@none.com</email></author><updated>2021-02-04T12:00:00Z</updated><link href="https://miles-harvey.tiiny.site/syllogisms/index.html" rel="alternate" /><summary type="html">&lt;p&gt;Syllogisms are a form of reasoning via deduction following two premises to arrive at a conclusion.&lt;/p&gt;&lt;p&gt;A syllogism consists of three parts:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Major premise&lt;/li&gt;&lt;li&gt;Minor premise&lt;/li&gt;&lt;li&gt;Conclusion&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Each premise contains a term in common with the conclusion. The major premise contains a major term, and the minor premise contains a minor term.&lt;/p&gt;&lt;h2&gt;Major types of syllogism&lt;/h2&gt;&lt;h3&gt;Categorical&lt;/h3&gt;&lt;p&gt;In logic, a categorical proposition, or categorical statement, is a proposition that asserts or denies that all or some of the members of one category (the subject term) are included in another (the predicate term).&lt;/p&gt;&lt;p&gt;Categorical syllogisms follow an “If A is part of C, then B is part of C” logic, or “If A is in C then B is in C”. For example: Wood is flammable. The desk is made of wood. Therefore the desk is flammable.&lt;/p&gt;&lt;p&gt;More generally, All M = P, All S = M, therefore All S = P.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Major Premise: Wood is flammable.&lt;/p&gt;&lt;p&gt;Minor Premise: My desk is made of wood.&lt;/p&gt;&lt;p&gt;Conclusion: My desk is flammable.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;There are two more types of categorical propositions based on quantifier:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Universal propositions, which describe either &amp;quot;all&amp;quot; or &amp;quot;none&amp;quot;, for example “All A are B,” and “No A are B”&lt;/li&gt;&lt;li&gt;Particular propositions, which describe &amp;quot;some&amp;quot; or &amp;quot;some not&amp;quot;, for example “some A are B,” and “some A are not B”&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Conditional&lt;/h3&gt;&lt;p&gt;Conditional syllogisms follow an &amp;quot;If A is true, then B is also true&amp;quot; logic. For example: If a car has fuel, then it’s engine can run. Conditional syllogisms are often referred to as hypothetical syllogisms because the arguments aren’t always valid.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Major premise: The car has fuel&lt;/p&gt;&lt;p&gt;Minor premise: Fuel powers a car’s engine.&lt;/p&gt;&lt;p&gt;Conclusion: The car's engine can run.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;In this case, the argument may not be valid, because despite the fact that fuel powers a car's engine, and despite the fact that the car has fuel, it's engine may not run, perhaps due to a fault.&lt;/p&gt;&lt;h3&gt;Disjunctive&lt;/h3&gt;&lt;p&gt;Disjunctive syllogisms follow the logic that either is correct, and that the noncorrect one implies the other is the correct one. For example: The floor is either wood or carpet. The floor is not carpet, therefore it’s wood.&lt;/p&gt;&lt;h2&gt;Minor types of syllogism&lt;/h2&gt;&lt;h3&gt;Enthymeme&lt;/h3&gt;&lt;p&gt;An Enthymeme is a syllogism with one part of the argument missing (either of the premises or the conclusion).&lt;/p&gt;&lt;h3&gt;Syllogistic Fallacy&lt;/h3&gt;&lt;p&gt;A syllogistic fallacy is a syllogism that contains a false presumption. For example: All crows are black. The bird in my cage is black. Therefore, the bird in my cage is a crow.&lt;/p&gt;&lt;h2&gt;Uses in Programming&lt;/h2&gt;&lt;p&gt;The strengths of syllogisms are that they allow us to deduce information we don't know based on a premise which we do know. As long as the premise is accurate, we can deduce accurate information without already knowing that information. This is especially useful in &lt;a href=&quot;big-thinking&quot;&gt;big thinking&lt;/a&gt; where we don't have all hte information necessary to work out an answer to a problem. We can use syllogisms to fill the incomplete information - for example, if I know that in a given day I will walk a certain distance, and I can predict that I take a certain number of steps when I walk a certain distance, then I can deduce the number of steps I take in a given day. Here I do not know the number of steps I take in a given day, but can deduce it based on the premise that I take a given number of steps when walking a given distance.&lt;/p&gt;&lt;p&gt;The problem with syllogisms however is that require an accurate premise: If the premise is inaccurate, then the conclusion will be inaccurate. Even worse than mere inaccuracy is the belief that the conclusion is accurate, because we believe the premise to be accurate. Since we are the ones that form the premise, we may be less inclined to see a problem in a premise and believe it to be true, which is why it would be important to open the premise to scrutiny, perhaps by getting feedback from others.&lt;/p&gt;&lt;p&gt;In programming, categorical syllogisms are very useful for rules. For example, we can deduce information about a given variable based on if it exists in a list. A syllogism rule using this logic could be:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Major premise: Variable A is in list L.&lt;/p&gt;&lt;p&gt;Minor premise: All members of list L are no longer needed by the application.&lt;/p&gt;&lt;p&gt;Conclusion: Therefore, variable A is not needed by the application.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;In this example, we deduce that variable A is no longer needed by the application, and therefore we can garbage-collect the variable. This process could also be expressed using another syllogism:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Major premise: Variable A is no longer needed by the application.&lt;/p&gt;&lt;p&gt;Minor premise: All variables that are no longer needed by the application are to be garbage-collected.&lt;/p&gt;&lt;p&gt;Conclusion: Therefore, variable A is to be garbage-collected.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Sources:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Wikipedia&lt;/li&gt;&lt;li&gt;https://examples.yourdictionary.com/examples-of-syllogism.html&lt;/li&gt;&lt;li&gt;http://changingminds.org/disciplines/argument/syllogisms/conditional_syllogism.htm&lt;/li&gt;&lt;/ul&gt;</summary></entry></feed>