<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/assets/theme/pixyll/css/pixyll.css" type="text/css" /><link href="//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic&amp;amp;subset=latin-ext,latin" rel="stylesheet" type="text/css" /><link href="//fonts.googleapis.com/css?family=Lato:900,300&amp;amp;subset=latin-ext,latin" rel="stylesheet" type="text/css" /></head><body class="animated fade-in-down"><div class="site-wrap"><div class="post p2 p-responsive wrap" role="main"><div class="measure"><title>V Model Strengths and Weaknesses</title><div class="post-header mb2"><header class="site-header px2 px-responsive"><div class="mt2 wrap"><div class="measure"><nav class="site-nav" style="float: left;"><a href="/" class="nav-link">‚Üê Return to index</a></nav><div class="clearfix"></div></div></div></header><header><hr /><h3>Digital Insights</h3><h1>V Model Strengths and Weaknesses</h1></header><hr /><br /></div><article class="post-content"><p>The &quot;V&quot; software development model is similar to the waterfall model in that each stage corresponds to a phase in the software development lifecycle, however instead of testing being a single stage after the development of the software, has testing applied to it.</p><h1>Strengths</h1><h2>More reliably structured codebase</h2><p>Emphasis on heavy testing encourages designing a system of which it's components can be tested, which implicitly encourages programmers to compartmentalise components, keeping them separate from eachother and thus the codebase being more structured.</p><p>Since testing at every stage gives feedback to developers as to how well components are differentiated and structured throughout the development lifecycle, rather than towards the end like with other methodologies, the structure of the software will be improved upon as the project progresses.</p><p>Since the plan doesn't change until it's released, more focus can be made on planning the requirements and a solid codebase/structure as it won't be changed. This will result in a more solidly structured codebase that is better thought-out and so more reliable.</p><h2>Verification and validation.</h2><h2>Tests are made during the creation of the project/product structure.</h2><h2>Software</h2><p>&lt;features of software that V model is bad for&gt;
&lt;Examples of software&gt;
Operating systems.</p><pre><code>ATMs.

Flight software - avionics.

Power plant operator software.

Mechanical devices/equipment that are controlled with a computer.

Ultimately, any kind of software which needs to be bug-free before release, that if isn't would cause harm to [quality of] life.
    Also, any kind of software to create a product ready to be used straight away.</code></pre><h1>Weaknesses:</h1><h2>Time</h2><p>More time spent on testing, less time spent on other things.</p><h2>Client/user feedback</h2><p>No feedback until release - Interface could be suboptimal.</p><h2>Lack of iteration and adaptability</h2><p>No iteration on product - project lives and dies by the planning stage.
Not able to adapt to changes, e.g. new technologies.</p><h2>Rigidly reliant on specification.</h2><h2>Software</h2><p>&lt;features of software that V model is bad for&gt;
&lt;Examples of software&gt;</p><h1>Conclusion</h1></article></div></div></div></body></html>